# Language Context for Grammar Generation

**Version:** 3.0 (Updated for Task 0 Planning Phase + TSGS Integration)  
**Date:** 2026-02-11

---

## Target Language Information
**Language Name:** [FILL IN - e.g., Python, JavaScript, Rust]  
**Target Version Range:** [FILL IN - e.g., 3.8-3.13, ES2015-ES2024]  
**Grammar Strategy:** [Superset | Versioned | Subset]

---

## Required Input Files

### Core Protocol Documents

#### 1. PAGS_PROTOCOL.md
**File Location:** `./PAGS_PROTOCOL.md`  
**Content:** 550-line Protocol for Algorithmic Grammar Synthesis  
**Purpose:** Defines Phases I-VII of grammar generation  
**Used in:** All tasks (master methodology)

#### 2. general_rules_de.md
**File Location:** `./general_rules_de.md`  
**Content:** Universal Semantic Graph (USG) specification  
**Purpose:** Defines NodeKind taxonomy, metadata schema, and architectural principles  
**Used in:** Task 0 (constraints extraction), Task 2 (mappings), Task 5 (validation)

#### 3. Official Grammar Specification
**Online Location:** [FILL IN URL - e.g., https://docs.python.org/3/reference/grammar.html]  
**Local File Location (if downloaded):** `./grammar_spec.txt` or `./grammar_spec.html`  
**Format:** EBNF, BNF, PEG, or official parser grammar  
**Purpose:** Source of truth for language syntax  
**Used in:** Task 0 (extraction into `specs/*.yaml`)

#### 4. Version History File
**Filename:** `[language]_history.json` (e.g., `python_history.json`)  
**File Location:** `./<language>_history.json`  
**Purpose:** Documents version-specific features, additions, removals  
**Used in:** Task 0 (version matrix generation), Task 4 (conflict context)

**Schema:**
```json
{
  "language": "string",
  "modern_version": "string",
  "reverse_timeline": [
    {
      "version_boundary": "string",
      "change_type": "Introduction" | "Removal" | "Modification",
      "feature": "string",
      "tree_sitter_nodes": {
        "added_nodes": ["string"],
        "removed_nodes": ["string"],
        "semantic_shift_nodes": ["string"]
      },
      "defolding_impact": {
        "description": "string",
        "legacy_behavior": "string",
        "edge_implications": "string"
      }
    }
  ]
}
```

#### 5. TASK_00_PLANNING_PHASE.md (NEW)
**File Location:** `./TASK_00_PLANNING_PHASE.md`  
**Content:** Task 0 specification - Planning & normalization phase  
**Purpose:** Defines extraction and spec generation procedures  
**Used in:** Task 0 execution (first mandatory step)

#### 6. TASK_01-06_*.md
**File Locations:** `./TASK_01_LEXICAL_FOUNDATION.md`, `./TASK_02_STRUCTURAL_SKELETON.md`, etc.  
**Content:** Task specifications for grammar implementation  
**Purpose:** Step-by-step implementation instructions  
**Used in:** Sequential task execution (Tasks 1-6)

#### 7. TASK_07_TSGS_REFINEMENT.md (NEW - Optional)
**File Location:** `./TASK_07_TSGS_REFINEMENT.md`  
**Content:** TSGS data-driven refinement procedures  
**Purpose:** Corpus-based grammar improvement  
**Used in:** Task 7 (if parse coverage < 99%)

#### 8. TSGS_INTEGRATION_PROTOCOL.md (NEW)
**File Location:** `./TSGS_INTEGRATION_PROTOCOL.md`  
**Content:** Complete TSGS methodology (decomposition, oracle, distributional matrix)  
**Purpose:** Detailed TSGS algorithms and implementation  
**Used in:** Task 7 reference

#### 9. SYNTHESIS_PLAN_TEMPLATE.md (NEW)
**File Location:** `./SYNTHESIS_PLAN_TEMPLATE.md`  
**Content:** Template for generated synthesis plan  
**Purpose:** Structure for SYNTHESIS_PLAN.md output  
**Used in:** Task 0 (plan generation)

---

## Task 0: Generated Specification Files (NEW)

**After Task 0 completes, the following normalized specifications are generated:**

### specs/lexical.yaml
**Generated by:** Task 0 Phase 1  
**Source:** Official grammar specification + `<language>_history.json`  
**Content:** Normalized lexical specification

**Structure:**
```yaml
language: <LANGUAGE_NAME>
spec_source: "<URL>"
spec_version: "<version>"

identifiers:
  pattern: "<regex>"
  restrictions: ["Cannot start with digit"]
  spec_reference: "<section>"

numbers:
  formats:
    - name: "decimal"
      pattern: "\\d+"
      spec_reference: "<section>"

strings:
  formats:
    - name: "double_quoted"
      pattern: '\"([^\"\\\\]|\\\\(.|\n))*\"'
      escape_sequences: ["\\n", "\\t"]

comments:
  single_line:
    delimiter: "//"
    pattern: "//.*"

keywords:
  core: ["if", "else", "for"]
  contextual: ["async", "await"]
  version_specific:
    - keyword: "match"
      min_version: "3.10"
```

**Used in:** Task 1 (atom implementation)

### specs/operators.yaml
**Generated by:** Task 0 Phase 1  
**Source:** Official grammar operator precedence table  
**Content:** Complete operator precedence and associativity

**Structure:**
```yaml
operators:
  - symbol: "="
    arity: "binary"
    precedence: 1
    associativity: "right"
    category: "assignment"
    spec_reference: "<section>"
  
  - symbol: "+"
    arity: "binary"
    precedence: 5
    associativity: "left"
    category: "additive"
```

**Used in:** Task 3 (PREC constant generation)

### specs/syntax.yaml
**Generated by:** Task 0 Phase 1  
**Source:** Official grammar EBNF rules  
**Content:** Structural hierarchy and major constructs

**Structure:**
```yaml
top_level:
  - "function_definition"
  - "class_definition"

ebnf_rules:
  function_definition:
    pattern: "'func' identifier '(' parameter_list ')' block"
    fields:
      - name: "name"
        type: "identifier"
        usg_role: "definition"
      - name: "body"
        type: "block"
```

**Used in:** Task 2 (skeleton implementation)

### specs/versions.yaml
**Generated by:** Task 0 Phase 1  
**Source:** `<language>_history.json` + official changelogs  
**Content:** Enhanced version matrix

**Structure:**
```yaml
language: <LANGUAGE_NAME>
version_strategy: "superset"

versions:
  - version: "3.10"
    release_date: "2021-10-04"
    features:
      added:
        - feature: "match_statement"
          syntax: "match VALUE: case PATTERN: BODY"
          nodes: ["match_statement", "case_clause"]

conflict_matrix:
  - construct_a: "type_cast"
    construct_b: "parenthesized_expression"
    resolution: "GLR branching"
```

**Used in:** Task 2 (version-specific rules), Task 4 (conflict context)

### specs/usg_constraints.yaml
**Generated by:** Task 0 Phase 1  
**Source:** `general_rules_de.md` Section III.A + IV  
**Content:** USG NodeKind mappings and metadata requirements

**Structure:**
```yaml
node_mappings:
  function_definition:
    usg_nodekind: "FunctionDef"
    category: "II. Funktionen & Logik"
    required_metadata:
      - name: "throws"
        type: "array<string>"
        derivable: false
    required_fields:
      - "name"
      - "body"
    traversal_strategy: "CreateAndContain"
```

**Used in:** Task 2 (USG mappings), Task 5 (validation)

### specs/edge_cases.yaml
**Generated by:** Task 0 Phase 1  
**Source:** Official grammar ambiguities + known parser issues  
**Content:** Documented edge cases and ambiguities

**Structure:**
```yaml
edge_cases:
  - id: "EC001"
    name: "Dangling else ambiguity"
    test_input: "if (a) if (b) x; else y;"
    expected_parse: "else binds to inner if"
    resolution_strategy: "prec.right on if_statement"
```

**Used in:** Task 4 (conflict resolution)

---

## Task 0 Execution: Jules Instructions

### Phase 0: Specification Extraction & Normalization (MANDATORY FIRST STEP)

**Jules Command for Task 0:**
```
Execute Task 0 Planning Phase according to TASK_00_PLANNING_PHASE.md.

Context:
- PAGS_PROTOCOL.md contains methodology
- CONTEXT.md (this file) contains grammar spec URL
- <language>_history.json contains version history
- general_rules_de.md contains USG requirements

Tasks:
1. Parse official grammar specification from [URL in this file]
2. Extract all lexical elements → generate specs/lexical.yaml
3. Extract operator precedence → generate specs/operators.yaml
4. Extract EBNF rules → generate specs/syntax.yaml
5. Parse <language>_history.json → generate specs/versions.yaml
6. Cross-reference general_rules_de.md → generate specs/usg_constraints.yaml
7. Document known ambiguities → generate specs/edge_cases.yaml
8. (Optional) Audit existing grammar → analysis/existing_grammar_audit.md
9. Generate SYNTHESIS_PLAN.md

Deliverables:
- Complete specs/ directory (6 YAML files)
- SYNTHESIS_PLAN.md
- All YAMLs must validate (yamllint)
- Every extraction must have source reference

CRITICAL: No grammar.js code written until SYNTHESIS_PLAN.md approved.
```

**Human Verification After Task 0:**
```bash
# Validate YAML syntax
yamllint specs/*.yaml

# Check completeness
ls specs/
# Expected: lexical.yaml, operators.yaml, syntax.yaml, versions.yaml, 
#           usg_constraints.yaml, edge_cases.yaml

# Review synthesis plan
cat SYNTHESIS_PLAN.md

# Approve before Task 1
```

---

## Tasks 1-6: Implementation Phase (Using Normalized Specs)

### Task 1: Lexical Foundation (Updated)

**Input Sources (CHANGED):**
- `specs/lexical.yaml` (generated in Task 0)
- `SYNTHESIS_PLAN.md` → Lexical Atoms section

**Jules Command:**
```
Implement Task 1 according to TASK_01_LEXICAL_FOUNDATION.md.

Use specs/lexical.yaml for all atom patterns.
Do NOT re-extract from specification (already done in Task 0).
Implement atoms directly from normalized specs with traceability preserved.

Reference: PAGS_PROTOCOL.md Phase I
```

### Task 2: Structural Skeleton (Updated)

**Input Sources (CHANGED):**
- `specs/syntax.yaml` (structural rules)
- `specs/usg_constraints.yaml` (USG mappings)
- `general_rules_de.md` Section III.A (NodeKind taxonomy)

**Jules Command:**
```
Implement Task 2 according to TASK_02_STRUCTURAL_SKELETON.md.

Use specs/syntax.yaml for structural rules.
Use specs/usg_constraints.yaml for USG NodeKind mappings.
Do NOT manually determine NodeKinds (already mapped in Task 0).

Reference: PAGS_PROTOCOL.md Phase II
```

### Task 3: Expression Engine (Updated)

**Input Sources (CHANGED):**
- `specs/operators.yaml` (precedence table)

**Jules Command:**
```
Implement Task 3 according to TASK_03_EXPRESSION_ENGINE.md.

Generate PREC constant DIRECTLY from specs/operators.yaml.
Do NOT manually determine precedence (already validated in Task 0).

Reference: PAGS_PROTOCOL.md Phase III
```

### Task 4: Conflict Resolution (Updated)

**Input Sources (CHANGED):**
- `specs/edge_cases.yaml` (known ambiguities)
- `specs/versions.yaml` (conflict matrix)

**Jules Command:**
```
Implement Task 4 according to TASK_04_CONFLICT_RESOLUTION.md.

Use specs/edge_cases.yaml for known conflict patterns.
Use specs/versions.yaml conflict_matrix for context-dependent ambiguities.

Reference: PAGS_PROTOCOL.md Phase IV
```

### Tasks 5-6: Unchanged
Follow original task specifications.

---

## Task 7: TSGS Refinement (NEW - Optional)

**When to Execute:**
- Parse coverage on real-world corpus < 99%
- Grammar works on test cases but fails on real code
- You have access to reference compiler/interpreter (oracle)

**Prerequisites:**
- Tasks 1-6 completed
- Real-world corpus collected (50k+ LOC)
- Reference compiler/interpreter available

**Jules Command:**
```
Execute Task 7 according to TASK_07_TSGS_REFINEMENT.md and TSGS_INTEGRATION_PROTOCOL.md.

Context:
- TSGS_INTEGRATION_PROTOCOL.md contains methodology
- specs/edge_cases.yaml contains known ambiguities
- Reference compiler: [FILL IN PATH - e.g., /usr/bin/python3]

Tasks:
1. Collect corpus: scripts/collect_corpus.sh
2. Parse and identify errors: scripts/parse_corpus.py
3. Build decomposition forest: scripts/decompose.py
4. Consult oracle for ambiguous cases
5. Build distributional matrix (if needed)
6. Augment grammar based on findings
7. Validate: measure_coverage.py (target ≥ 99%)

Deliverables:
- corpus/ directory
- analysis/parse_errors.json, minimal_failing.json
- tsgs_augmentations/new_productions.js
- TSGS_REFINEMENT_LOG.md

Reference: TSGS_INTEGRATION_PROTOCOL.md Phases 1-5
```

---

## Universal Semantic Graph (USG) Integration

### NodeKind Mapping Requirements

**For EVERY tree-sitter node, determine correct `NodeKind` from `general_rules_de.md` Section III.A.**

**In Task 0:** Mappings are pre-computed and stored in `specs/usg_constraints.yaml`.  
**In Task 2:** Implement mappings directly from `usg_constraints.yaml`.

**Mapping Principle:**
```
Tree-sitter AST Node → USG NodeKind
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
function_definition  → FunctionDef
class_declaration    → ClassDef
import_statement     → Import
identifier (read context) → Reference
call_expression      → Call
```

**Mandatory Categories from general_rules_de.md:**
1. **Struktur & Organisation:** Module, ClassDef, InterfaceDef, Block
2. **Funktionen & Logik:** FunctionDef, MethodDef, Call, Expression
3. **Daten & Variablen:** VariableDef, Field, Assignment, Reference
4. **Kontrollfluss:** IfStatement, Loop, MatchExpression, ReturnStatement
5. **Konnektivität:** Import, Export, Annotation
6. **Nebenläufigkeit:** Await, Yield, Spawn (if applicable)

### Metadata Schema Requirements

**For EVERY `SemanticNode`, populate metadata according to `general_rules_de.md` Section III.A + IV.**

**Mandatory Fields (Example FunctionDef from usg_constraints.yaml):**
```javascript
metadata: {
  // From III.A Table (NodeKind-specific)
  throws: ["ExceptionType1", "ExceptionType2"],

  // From IV Table (General Flags)
  visibility: "public" | "private" | "protected",
  is_async: true,
  is_static: false,

  // Source Fidelity (Contract 5)
  range: { start: {row, column}, end: {row, column} },
  content_hash: "sha256_hash"
}
```

**STRICT PROHIBITIONS (Principle 1: Non-Redundancy):**
```javascript
// ❌ FORBIDDEN:
metadata: {
  dependencies: [...],      // Derivable from graph
  statement_count: 5,       // Derivable from edges
  argument_count: 3         // Derivable from edges
}
```

### Field Assignment Protocol

**Apply `field()` for ALL semantically relevant child nodes.**

**Example (per general_rules_de.md Contract 1):**
```javascript
function_definition: $ => seq(
  'func',
  field('name', $.identifier),          // ✓ Mandatory
  field('parameters', $.parameter_list), // ✓ Mandatory
  field('body', $.block)                 // ✓ Mandatory
),
```

### Traversal Strategy Protocol

**For EVERY tree-sitter node, determine correct `TraversalStrategy` (defined in specs/usg_constraints.yaml):**

- **`CreateAndContain`:** Node becomes SemanticNode, children traversed
- **`Dissolve`:** Node does NOT become SemanticNode, children processed directly
- **`Terminal`:** Node becomes SemanticNode, children NOT traversed

**Dissolution Candidates (Principle 3):**
```javascript
// These create NO own SemanticNode:
_statement: $ => choice(...),           // Wrapper
_expression: $ => choice(...),          // Wrapper
parenthesized_expression: $ => seq('(', $.expression, ')'),  // Syntactic wrapper
expression_statement: $ => seq($.expression, ';')            // Syntactic container
```

---

## Version-Specific Grammar Features

**Implement version ranges based on `specs/versions.yaml` (generated in Task 0).**

**CRITICAL:** Version ranges are **TUPLES** `[min_inclusive, max_exclusive]` because features can be introduced and removed.

**Data Structure:**
```yaml
# In specs/versions.yaml
version_constraints:
  match_statement:
    valid_ranges:
      - ["3.10", null]  # Available from 3.10 onward
  
  print_statement:
    valid_ranges:
      - [null, "3.0"]   # Removed in Python 3.0
```

**Grammar Implementation:**
```javascript
// grammar.js
// For superset grammar, both constructs parse
match_statement: $ => seq('match', ...),
print_statement: $ => seq('print', ...),

// Version filtering happens in semantic transformation, not grammar
```

**Semantic Annotation (in transform logic):**
```python
# match_statement → SemanticNode
{
  "nodekind": "MatchExpression",
  "metadata": {
    "valid_version_ranges": [["3.10", null]],
    "version_origin": "syntax"
  }
}

# print_statement → SemanticNode  
{
  "nodekind": "PrintStatement",
  "metadata": {
    "valid_version_ranges": [[null, "3.0"]],
    "version_origin": "syntax"
  }
}
```

**Version Inference:**
```python
# File uses both match and async (≥3.5)
# Intersection: [["3.10", null]] ∩ [["3.5", null]] = [["3.10", null]]
# Result: File requires Python ≥3.10
```

---

## Query Layer Requirements

**Create `queries/*.scm` based on USG NodeKind mapping from specs/usg_constraints.yaml.**

**highlights.scm Pattern:**
```scheme
; Map to USG-aware Captures
(function_definition
  name: (identifier) @function.definition)  ; → FunctionDef in USG

(call_expression
  function: (identifier) @function.call)     ; → Call in USG

(identifier) @variable.reference             ; → Reference in USG
```

**locals.scm Pattern:**
```scheme
; Scope-Tracking for USG
(block) @local.scope                         ; → Block NodeKind

(function_definition
  name: (identifier) @local.definition)      ; → FunctionDef (definition: true)

(identifier) @local.reference                ; → Reference (definition: false)
```

---

## Conflict Resolution with Version Context

**On `tree-sitter generate` conflicts, consult `specs/edge_cases.yaml` and `specs/versions.yaml`.**

**Example from versions.yaml:**
```yaml
conflict_matrix:
  - construct_a: "async_function"
    construct_b: "identifier_async"
    context: "Pre-3.5: 'async' can be identifier; Post-3.5: 'async' is keyword"
    resolution: "GLR branching"
```

**Resolution in grammar.js:**
```javascript
conflicts: $ => [
  // GLR branching for version ambiguity
  [$.identifier, $.async_keyword]
],
```

---

## Documentation Requirements

**Jules Deliverables per Task:**

### Task 0 (NEW)
1. **`specs/lexical.yaml`** - Normalized lexical specification
2. **`specs/operators.yaml`** - Complete precedence table
3. **`specs/syntax.yaml`** - Structural EBNF rules
4. **`specs/versions.yaml`** - Enhanced version matrix
5. **`specs/usg_constraints.yaml`** - USG mapping requirements
6. **`specs/edge_cases.yaml`** - Edge case corpus
7. **`SYNTHESIS_PLAN.md`** - Execution roadmap
8. **`analysis/existing_grammar_audit.md`** (optional)

### Tasks 1-6
1. **`ATOMS_VERIFICATION.md`** (Task 1)
2. **`USG_MAPPING.md`** (Task 2) - References `specs/usg_constraints.yaml`
3. **`FIELD_COVERAGE.md`** (Task 2)
4. **`EXPRESSION_PRECEDENCE.md`** (Task 3) - References `specs/operators.yaml`
5. **`CONFLICTS_LOG.md`** (Task 4) - References `specs/edge_cases.yaml`
6. **`RESOLUTION_SUMMARY.md`** (Task 4)
7. **`SUPERTYPE_VALIDATION.md`** (Task 5)
8. **`FINAL_VERIFICATION_REPORT.md`** (Task 6)

### Task 7 (Optional)
1. **`TSGS_REFINEMENT_LOG.md`** - Complete audit trail
2. **`corpus/`** - Real-world code samples
3. **`analysis/parse_errors.json`** - Error mining results
4. **`analysis/minimal_failing.json`** - Decomposition results
5. **`tsgs_augmentations/`** - New productions

---

## Validation Checklist

**Before Task 0:**
- [ ] PAGS_PROTOCOL.md exists and is readable
- [ ] general_rules_de.md exists and is readable
- [ ] Official grammar spec URL/file is accessible
- [ ] `<language>_history.json` exists and is valid JSON (`python3 -m json.tool`)
- [ ] tree-sitter CLI is installed (`tree-sitter --version`)
- [ ] All task documents (TASK_00-07, TSGS_INTEGRATION_PROTOCOL, etc.) present

**After Task 0:**
- [ ] `specs/` directory exists with 6 YAML files
- [ ] All YAMLs validate: `yamllint specs/*.yaml`
- [ ] `SYNTHESIS_PLAN.md` exists and is approved
- [ ] All extractions have source references

**After Task 6:**
- [ ] `tree-sitter generate` → 0 warnings, 0 conflicts
- [ ] `tree-sitter test` → 100% pass rate
- [ ] Real-world samples parse correctly

**After Task 7 (if executed):**
- [ ] Parse coverage ≥ 99%
- [ ] No regressions on Tasks 1-6 test suites

---

## Post-Grammar Usage

After grammar generation is complete, the generated artifacts can be used for:

1. **Syntax Highlighting:** Via `queries/highlights.scm`
2. **Code Navigation:** Via `queries/tags.scm`
3. **Semantic Analysis:** Via `queries/locals.scm`
4. **USG Transformation:** Via `specs/usg_constraints.yaml` + transform pipeline
5. **Custom Tooling:** Parse trees accessible via tree-sitter APIs

**Generated files:**
- `src/parser.c` - Compiled parser
- `src/node-types.json` - AST node schema
- `src/grammar.json` - Grammar structure
- `queries/*.scm` - Query files

**Normalized specifications (preserved for reference):**
- `specs/*.yaml` - All normalized specifications from Task 0

---

## Example: Complete Workflow Overview

```
1. Setup Repository
   ├─ Add PAGS_PROTOCOL.md, general_rules_de.md
   ├─ Add CONTEXT.md (this file - filled)
   ├─ Add <language>_history.json (filled + validated)
   └─ Add TASK_00-07, TSGS_INTEGRATION_PROTOCOL, etc.

2. Task 0: Planning Phase (MANDATORY FIRST)
   ├─ Extract from official grammar spec
   ├─ Generate specs/*.yaml (6 files)
   ├─ Generate SYNTHESIS_PLAN.md
   └─ Human approval required

3. Tasks 1-6: Implementation (Sequential)
   ├─ Task 1: Atoms (uses specs/lexical.yaml)
   ├─ Task 2: Structure (uses specs/syntax.yaml + usg_constraints.yaml)
   ├─ Task 3: Expressions (uses specs/operators.yaml)
   ├─ Task 4: Conflicts (uses specs/edge_cases.yaml + versions.yaml)
   ├─ Task 5: Semantization (uses specs/usg_constraints.yaml)
   └─ Task 6: Verification

4. Task 7: TSGS Refinement (Optional)
   ├─ Only if corpus coverage < 99%
   ├─ Requires oracle (reference compiler)
   └─ Data-driven grammar improvement

5. Release
   └─ git tag v1.0.0
```
---



---

**Document Version:** 3.0  
**Last Updated:** 2026-02-11  
**Changes:** Added Task 0 specification extraction, TSGS integration, normalized specs/ directory references